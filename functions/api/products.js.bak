// Cloudflare Pages Function - Products API Endpoint
export async function onRequest(context) {
  const { request, env } = context;
  
  // CORS headers for all responses
  const corsHeaders = {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type',
    'Content-Type': 'application/json'
  };

  // Handle OPTIONS requests for CORS preflight
  if (request.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const { DB } = env;
    
    // Check if database is configured
    if (!DB) {
      return new Response(JSON.stringify({
        error: 'Database not configured',
        message: 'D1 database binding not found'
      }), {
        status: 500,
        headers: corsHeaders
      });
    }

    // Handle different HTTP methods
    switch (request.method) {
      case 'GET':
        // Get all products
        const { results } = await DB.prepare(
          'SELECT * FROM products ORDER BY created_at DESC'
        ).all();
        
        // Transform data to match frontend expectations
        const products = results.map(product => ({
          id: product.id.toString(),
          category: product.category,
          image: product.image || "https://via.placeholder.com/300x200",
          name: {
            en: product.name_en,
            tr: product.name_tr,
            de: product.name_de || product.name.en
          },
          features: {
            en: JSON.parse(product.features_en || '[]'),
            tr: JSON.parse(product.features_tr || '[]')
          },
          badges: product.badges ? product.badges.split(',') : [],
          retail_price: product.retail_price,
          min_wholesale_quantity: product.min_wholesale_quantity,
          in_stock: Boolean(product.in_stock),
          stock_quantity: product.stock_quantity,
          priceTiers: JSON.parse(product.price_tiers || '[]')
        }));

        return new Response(JSON.stringify({
          success: true,
          data: products,
          count: products.length
        }), {
          status: 200,
          headers: corsHeaders
        });

      case 'POST':
        // Add new product
        const productData = await request.json();
        
        try {
          const insertResult = await DB.prepare(`
            INSERT INTO products (
              category, 
              name_en, 
              name_tr, 
              name_de, 
              image, 
              features_en, 
              features_tr, 
              badges, 
              retail_price, 
              min_wholesale_quantity, 
              stock_quantity, 
              in_stock,
              price_tiers,
              created_at
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, datetime('now'))
          `).bind(
            productData.category,
            productData.name.en,
            productData.name.tr,
            productData.name.de || productData.name.en,
            productData.image || "https://via.placeholder.com/300x200",
            JSON.stringify(productData.features?.en || []),
            JSON.stringify(productData.features?.tr || []),
            Array.isArray(productData.badges) ? productData.badges.join(',') : '',
            productData.retail_price,
            productData.min_wholesale_quantity,
            productData.stock_quantity || 0,
            Boolean(productData.in_stock),
            JSON.stringify(productData.priceTiers || [])
          ).run();

          return new Response(JSON.stringify({
            success: true,
            message: 'Product created successfully',
            id: insertResult.lastRowId
          }), {
            status: 201,
            headers: corsHeaders
          });

        } catch (error) {
          console.error('Error inserting product:', error);
          return new Response(JSON.stringify({
            error: 'Failed to create product',
            message: error.message
          }), {
            status: 400,
            headers: corsHeaders
          });
        }

      case 'PUT':
        // Update existing product
        const { id, ...updateData } = await request.json();
        if (!id) {
          return new Response(JSON.stringify({
            error: 'Invalid request',
            message: 'Product ID is required'
          }), {
            status: 400,
            headers: corsHeaders
          });
        }

        try {
          const updateResult = await DB.prepare(`
            UPDATE products SET
              category = ?,
              name_en = ?,
              name_tr = ?,
              name_de = ?,
              image = ?,
              features_en = ?,
              features_tr = ?,
              badges = ?,
              retail_price = ?,
              min_wholesale_quantity = ?,
              stock_quantity = ?,
              in_stock = ?,
              price_tiers = ?
            WHERE id = ?
          `).bind(
            updateData.category,
            updateData.name.en,
            updateData.name.tr,
            updateData.name.de || updateData.name.en,
            updateData.image || "https://via.placeholder.com/300x200",
            JSON.stringify(updateData.features?.en || []),
            JSON.stringify(updateData.features?.tr || []),
            Array.isArray(updateData.badges) ? updateData.badges.join(',') : '',
            updateData.retail_price,
            updateData.min_wholesale_quantity,
            updateData.stock_quantity || 0,
            Boolean(updateData.in_stock),
            JSON.stringify(updateData.priceTiers || []),
            id
          ).run();

          if (updateResult.changes === 0) {
            return new Response(JSON.stringify({
              error: 'Not found',
              message: 'Product not found'
            }), {
              status: 404,
              headers: corsHeaders
            });
          }

          return new Response(JSON.stringify({
            success: true,
            message: 'Product updated successfully'
          }), {
            status: 200,
            headers: corsHeaders
          });

        } catch (error) {
          console.error('Error updating product:', error);
          return new Response(JSON.stringify({
            error: 'Failed to update product',
            message: error.message
          }), {
            status: 400,
            headers: corsHeaders
          });
        }

      case 'DELETE':
        // Delete product
        const deleteData = await request.json();
        if (!deleteData.id) {
          return new Response(JSON.stringify({
            error: 'Invalid request',
            message: 'Product ID is required'
          }), {
            status: 400,
            headers: corsHeaders
          });
        }

        try {
          const deleteResult = await DB.prepare('DELETE FROM products WHERE id = ?')
            .bind(deleteData.id)
            .run();

          if (deleteResult.changes === 0) {
            return new Response(JSON.stringify({
              error: 'Not found',
              message: 'Product not found'
            }), {
              status: 404,
              headers: corsHeaders
            });
          }

          return new Response(JSON.stringify({
            success: true,
            message: 'Product deleted successfully'
          }), {
            status: 200,
            headers: corsHeaders
          });

        } catch (error) {
          console.error('Error deleting product:', error);
          return new Response(JSON.stringify({
            error: 'Failed to delete product',
            message: error.message
          }), {
            status: 400,
            headers: corsHeaders
          });
        }

      default:
        return new Response(JSON.stringify({
          error: 'Method not allowed',
          message: `${request.method} is not supported`
        }), {
          status: 405,
          headers: corsHeaders
        });
    }

  } catch (error) {
    console.error('Server error:', error);
    return new Response(JSON.stringify({
      error: 'Internal Server Error',
      message: error.message
    }), {
      status: 500,
      headers: corsHeaders
    });
  }
}